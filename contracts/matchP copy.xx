// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./library/ABDKMath64x64.sol";
import "./interface/ImatchP.sol";

contract MatchP is OwnableUpgradeable, UUPSUpgradeable, ImatchP {
    using ABDKMath64x64 for int128;

    address public token; // match代币地址
    uint256 public feeRate; // 抽成比例点数
    uint256 public feeDecimals; // 抽成比例分母
    address public MatchProtocol; // 协议收取match代币地址
    uint256 public _nonce; // 赛事ID计数器，从0开始

    uint256 public startAppend; // limit start time
    uint256 public endAppend; //  limit end time
    uint256 public _totalScore; // 积分池
    uint256 public index0; // 当前赛事数组的iNDex

    mapping(uint256 => game) public games; // mapping optimize gas
    // 标记是否是参赛者
    mapping(uint256 => mapping(address => bool)) public isPlayer;
    // 赛事某个用户接受的票数总额, 赛事id=>(用户地址=>(票数))
    mapping(uint256 => mapping(address => uint256)) public playerStakeBalance;
    // 用户在某个赛事对某个玩家的质押信息
    mapping(address => mapping(uint256 => stakeInfo)) public voterGameStake;
    // 创建赛事的白名单
    mapping(address => bool) public whiteList;

    // 参赛者列表
    mapping(uint256 => address[]) public Aplayers;
    // 质押/投票者列表
    mapping(uint256 => address[]) public Avoters;
    // 用户vote积分
    mapping(address => uint256) public voteBalance;
    // 是否领取过代币
    mapping(address => bool) public isGain;

    gameInfo[] public gameInfoList;

    struct gameInfo {
        uint256 id;
        string name;
        address[] players;
        uint256 startTime;
        uint256 endTime;
        uint256 isSettled;
        uint256 player0Balance;
        uint256 player1Balance;
    }

    struct stakeInfo {
        uint256 gameId;
        address player;
        uint256 stakeAmount; // 投票数量
    }

    struct game {
        string name;
        uint256 id;
        uint256 startTime;
        uint256 endTime;
        uint8 exist; // 1: 存在, 0: 不存在
        uint8 isSettled; // 1: 已结算, 0: 未结算
        uint256 averageScore;
        uint256 index_slot; // index -> nonce,  0->1
    }

    event CreateGame(
        uint256 indexed gameId,
        string indexed _name,
        uint256 startTime,
        uint256 endTime,
        address builder
    );
    event JoinGame(uint256 gameId, address player);
    event Settle(
        uint256 gameId,
        address winnerVoter,
        uint256 _time,
        uint256 _bonus
    );
    event Settled(uint256 gameId, address winner, uint256 _time);
    event DoNothing(address indexed sender);
    // event Vote(uint256 gameId, address voter, uint256 amount);  // 记录的是投了多少积分
    event Vote(uint256 gameId, address voter, address player, uint256 amount);
    error GameAlreadyOver();

    modifier checkAuthority() {
        require(
            whiteList[msg.sender] || msg.sender == owner(),
            "not in white list"
        );
        _;
    }

    modifier limitStake(uint256 _gameId, address _player) {
        require(!isPlayer[_gameId][_player], "player can't stake");
        _;
    }

    modifier IsSettled(uint256 _gameId) {
        require(games[_gameId].isSettled == 0, "game is settled");
        _;
    }

    function initialize(
        address protocol,
        uint256 st,
        uint256 et
    ) public initializer {
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();

        _nonce = 1; // 从0开始
        feeRate = 10;
        feeDecimals = 10 ** 2;
        startAppend = st;
        endAppend = et;
        MatchProtocol = protocol;
        gameInfoList.push(
            gameInfo({
                id: 0,
                name: "default",
                players: new address[](0),
                startTime: 0,
                endTime: 180,
                isSettled: 0,
                player0Balance: 0,
                player1Balance: 0
            })
        );
    }

    function setToken(address _token) public onlyOwner {
        token = _token;
    }

    /*
    @title  matchP.createGame()
    @param  _name: 赛事名称, _startTime: 赛事开始时间(必须大于当前时间360), _endTime: 赛事结束时间 (必须大于开始时间180s,可以填大点)
    @notice  创建赛事
    @dev  需要用户发起调用
    @return  uint256  赛事ID
    */
    function createGame(
        string memory _name,
        uint256 _startTime,
        uint256 _endTime
    ) public returns (uint256) {
        require(
            _startTime > block.timestamp + startAppend,
            "Start time must be in the future"
        );
        require(
            _endTime > _startTime + endAppend,
            "End time must be at least endAppend after start"
        );
        uint256 gameId = _nonce;
        games[gameId] = game(
            _name,
            gameId,
            _startTime,
            _endTime,
            1,
            0,
            0,
            gameInfoList.length
        );

        if (index0 == 0) {
            gameInfoList[index0].id = _nonce;
            gameInfoList[index0].name = _name;
            gameInfoList[index0].startTime = _startTime;
            gameInfoList[index0].endTime = _endTime;
        } else {
            gameInfoList.push(
                gameInfo({
                    id: gameId,
                    name: _name,
                    players: new address[](0), // 初始化为空，实际玩家从 Aplayers 获取
                    startTime: _startTime,
                    endTime: _endTime,
                    isSettled: 0,
                    player0Balance: 0,
                    player1Balance: 0
                })
            );
        }

        index0++;
        _nonce++;
        emit CreateGame(gameId, "New Game", _startTime, _endTime, msg.sender);
        return gameId;
    }

    /** 
    @notice  仅首次领取成功,已领过会失败
    @notice  获取match代币
    @dev  需要用户发起调用
    @return  bool  true: 成功 false: 失败
    */
    function getToken() public returns (bool) {
        require(isGain[msg.sender] == false, "already gained");
        require(msg.sender != address(0), "token is zero");
        // IERC20(token).transfer(msg.sender, 30);
        require(_getToken(msg.sender), "get token fail");
        isGain[msg.sender] = true;
        return true;
    }

    /*
     */
    function _getToken(address to) internal returns (bool) {
        IERC20(token).transfer(to, 30);
        return true;
    }

    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyOwner {}

    /** 
    @dev  需要用户发起调用
    @param  _gameId: 赛事ID,
    @param  _player: 参赛者地址, 
    @param amount: vote积分,必须是10的整数倍
    @notice  接口 matchP.vote()
    
    @return  bool  true: 成功 false: 失败
    */
    function vote(
        uint256 _gameId,
        address _player,
        uint256 amount
    ) public limitStake(_gameId, msg.sender) returns (bool) {
        require(games[_gameId].exist == 1, "game does not exist");
        require(
            block.timestamp < games[_gameId].startTime,
            "only can vote before game start"
        );
        require(isPlayer[_gameId][_player], "invalid target player");
        require(
            voteBalance[msg.sender] >= amount && amount >= 100,
            "invalid Match token stake balance"
        );
        require(amount % 10 == 0, "Number must be divisible by 10");

        uint256 _fee = (amount * feeRate) / feeDecimals;
        voteBalance[MatchProtocol] += _fee;
        // IERC20(token).transfer(MatchProtocol, _fee);
        // IERC20(token).transferFrom(msg.sender, MatchProtocol, _fee);
        // IERC20(token).transferFrom(msg.sender, address(this), amount - _fee);
        playerStakeBalance[_gameId][_player] += amount - _fee; // 某个用户收到了多少vote票
        voterGameStake[msg.sender][_gameId] = stakeInfo(
            _gameId,
            _player,
            amount - _fee
        );

        Avoters[_gameId].push(msg.sender); // 添加投票者
        emit Vote(_gameId, msg.sender, _player, amount - _fee);

        return true;
    }

    function settlement(uint256 _gameId) public returns (bool) {
        require(games[_gameId].exist == 1, "game does not exist");
        require(
            block.timestamp > games[_gameId].endTime,
            "not in settlement period"
        );
        require(games[_gameId].isSettled == 0, "game is settled");

        address[] storage players = Aplayers[_gameId];
        address[] storage voters = Avoters[_gameId];
        require(players.length == 2, "invalid players in this game");

        uint256 player1Bal = playerStakeBalance[_gameId][players[0]];
        uint256 player2Bal = playerStakeBalance[_gameId][players[1]];
        address winner;
        address loser;
        if (player1Bal > player2Bal) {
            winner = players[0];
            loser = players[1];
        } else {
            winner = players[1];
            loser = players[0];
        }

        uint256 totalWinning = playerStakeBalance[_gameId][winner];
        uint256 totalLosing = playerStakeBalance[_gameId][loser];
        totalWinning = totalWinning / 10;
        totalLosing = totalLosing / 10;
        for (uint i = 0; i < voters.length; i++) {
            if (voterGameStake[voters[i]][_gameId].player == winner) {
                voterGameStake[voters[i]][_gameId].stakeAmount =
                    voterGameStake[voters[i]][_gameId].stakeAmount /
                    10;

                uint256 bonus = calculateBonusTwoDecimals(
                    voterGameStake[voters[i]][_gameId].stakeAmount,
                    totalWinning,
                    totalLosing
                );
                uint256 _total = bonus +
                    voterGameStake[voters[i]][_gameId].stakeAmount;

                transferToken(voters[i], _total);
                emit Settle(_gameId, voters[i], block.timestamp, _total);
            }
        }
        games[_gameId].isSettled = 1;
        emit Settled(_gameId, winner, block.timestamp);
        return true;
    }

    function transferToken(
        address _to,
        uint256 _amount
    ) internal checkAuthority returns (bool) {
        IERC20(token).transfer(_to, _amount);
        return true;
    }

    /**
     * @notice  参加赛事接口
       @dev 需要用户调用
     * @param _gameId 赛事id@
     */
    function joinGame(uint256 _gameId) public returns (bool) {
        require(games[_gameId].exist == 1, "game is not exist");
        // require(games[_gameId].isSettled == 0, "game is settled");
        require(!(isPlayer[_gameId][msg.sender] == true), "already join game");
        address[] storage players = Aplayers[_gameId];
        require(players.length < 2 || players.length == 1, "Game is full");
        players.push(msg.sender);
        isPlayer[_gameId][msg.sender] = true;
        // if (players.length == 0) {
        //     playerStakeBalance[_gameId][msg.sender] = 100;
        //     playerStakeBalance[_gameId][address(this)] = 200;
        // } else {
        //     delete playerStakeBalance[_gameId][address(this)];
        //     playerStakeBalance[_gameId][address(this)] = 200;
        // }

        emit JoinGame(_gameId, msg.sender);
        return true;
    }

    function isVoting(uint256 _gameId) public view returns (bool) {
        return block.timestamp > games[_gameId].endTime;
    }

    function forceGameOver(
        uint256 _gameId
    ) public checkAuthority returns (bool) {
        // no need change
        require(games[_gameId].exist == 1, "game does not exist");
        if (games[_gameId].endTime < block.timestamp) {
            revert GameAlreadyOver();
        }
        games[_gameId].endTime = block.timestamp;
        return true;
    }

    function calculateBonusTwoDecimals(
        uint256 _stake,
        uint256 totalWinning,
        uint256 totalLosing
    ) public pure returns (uint256 bonus) {
        require(totalWinning > 0, "totalWinning must be > 0");
        int128 stakeFP = ABDKMath64x64.fromUInt(_stake);
        int128 totalWinningFP = ABDKMath64x64.fromUInt(totalWinning);
        int128 totalLosingFP = ABDKMath64x64.fromUInt(totalLosing);
        int128 proportion = ABDKMath64x64.div(stakeFP, totalWinningFP);
        int128 bonusFP = ABDKMath64x64.mul(totalLosingFP, proportion);
        uint256 bonusTimes100 = ABDKMath64x64.toUInt(
            ABDKMath64x64.mul(bonusFP, ABDKMath64x64.fromUInt(100))
        );
        bonus = bonusTimes100 / 100;
        return bonus;
    }

    function addWhiteList(address addr) public checkAuthority returns (bool) {
        whiteList[addr] = true;
        return true;
    }

    // 获取当赛事总数
    function getGameCount() public view returns (uint256) {
        return _nonce;
    }

    /**
     * @notice 质押match代币获取积分
     * @dev 质押match代币获取积分
     * @param _amount match代币数量
     */
    function stake(address _staker, uint256 _amount) external returns (bool) {
        // require
        require(token == msg.sender, "token is not matchToken");
        voteBalance[_staker] += _amount * 10;
        _totalScore += _amount * 10;
        return true;
    }

    /**
     * @notice 获取所有赛事基本信息,开始时间,结束时间,赛事名称,参赛者
     * @dev 无需用户调用,通过rpc节点调用,参赛者的名称可以默认为左甲方,右乙方
     * @return gameInfoList
     */
    function getAllGames() public view returns (gameInfo[] memory) {
        gameInfo[] memory gameInfoList0 = new gameInfo[](_nonce - 1); // 动态分配数组，从 _nonce=1 开始
        for (uint i = 1; i < _nonce; i++) {
            // 从 gameId=1 开始遍历
            game memory g = games[i];
            if (g.exist == 0) continue; // 跳过不存在的赛事

            address[] memory players = Aplayers[i]; // 从 Aplayers 获取最新玩家列表
            gameInfo memory gi = gameInfo({
                id: g.id,
                name: g.name,
                players: players,
                startTime: g.startTime,
                endTime: g.endTime,
                isSettled: g.isSettled,
                player0Balance: 0,
                player1Balance: 0
            });

            // 检查 players 长度，避免越界
            if (players.length == 2) {
                gi.player0Balance = playerStakeBalance[i][players[0]];
                gi.player1Balance = playerStakeBalance[i][players[1]];
            } else if (players.length == 1) {
                gi.player0Balance = playerStakeBalance[i][players[0]];
                gi.player1Balance = 0;
            }

            gameInfoList0[i - 1] = gi; // 填充返回数组
        }
        return gameInfoList0;
    }

    // /**
    //  * @notice 获取vote结果
    //  * @dev 无需用户调用,通过rpc节点调用. 注意返回结果
    //  * @param _gameId 赛事id
    //  * @param player1 左边参赛者
    //  * @param player2 右边参赛者
    //  */
    // function finalScore(
    //     uint256 _gameId,
    //     address player1,
    //     address player2
    // ) public view returns (uint256[] memory scores) {
    //     require(games[_gameId].exist == 1, "game does not exist");
    //     scores = new uint256[](2);
    //     if (games[_gameId].isSettled == 1) {
    //         scores[0] = playerStakeBalance[_gameId][player1];
    //         scores[1] = playerStakeBalance[_gameId][player2];
    //     } else {
    //         scores[0] = 0;
    //         scores[1] = 0;
    //     }
    //     return scores;
    // }
}
